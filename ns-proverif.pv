(*
1. A->S: A, B, Na
2. S->A: {Na, Kab, B, {Kab, A}Kbs}Kas
  * A checks that recipient's name natches (B=B)
  * A checks that nonce Na matches
3. A->B: {Kab, a}Kbs
4. B->A: {Nb}Kab
5. A->B: {Nb+1}Kab
  * B checks that nonce Nb matches
*)

free c: channel.
(*set keyCompromise = approx.*)

type host.
type key.
free kBS: key [private].
free kAS: key [private].

free A, B: host.

event A_accept_key(key).
event A_completes_protocol(key).
event B_runs_protocol(bitstring).
event B_accept_key(key).

query k: key, x: bitstring; event(A_completes_protocol(k))==>event(B_runs_protocol(x)).
query k: key; event(A_accept_key(k)) && attacker(k)==>false.
query k: key; event(B_accept_key(k)) && attacker(k)==>false.

fun encrypt(bitstring, key): bitstring.
reduc forall m: bitstring, k: key; decrypt(encrypt(m,k),k) = m.

fun addition(bitstring, nat): bitstring.
reduc forall x:bitstring, y:nat; subtraction(addition(x,y),y)=x.

let clientA(kAS:key) =
  new nA: bitstring; 
  out(c, (A, B, nA));
  in(c, x: bitstring);
  let (received_nA: bitstring, received_kAB: key, received_hostB: host, received_Ma: bitstring) = decrypt(x, kAS) in
  if received_hostB = B then
  if received_nA = nA then
  event A_accept_key(received_kAB);
  out(c, received_Ma);
  in(c, z: bitstring);
  let received_B_nB = decrypt(z, received_kAB) in
  event A_completes_protocol(received_kAB);
  out(c, encrypt(addition(received_B_nB, 1), received_kAB)).

let serverS(kAS:key, kBS: key, kAB: key) =
  in(c, (hostA: host, hostB: host, SnA: bitstring));
  let Ma = encrypt((kAB, A), kBS) in
  out(c, encrypt((SnA, kAB, B, Ma), kAS)).

let clientB(kBS:key) = 
  in(c, y: bitstring);
  let (received_A_kAB: key, received_hostA: host) = decrypt(y, kBS) in
  new nB: bitstring; 
  event B_runs_protocol(nB);
  out(c, encrypt(nB, received_A_kAB));
  in(c, m: bitstring);
  let nB_modified = decrypt(m, received_A_kAB) in
  let nB_modified_unmodified = subtraction(nB_modified, 1) in
  if nB_modified_unmodified = nB then
  event B_accept_key(received_A_kAB).

process
  new kAB: key;
  
  ( (!clientA(kAS)) | (!serverS(kAS, kBS, kAB)) | (!clientB(kBS)) | phase 1; out(c, kAB))
