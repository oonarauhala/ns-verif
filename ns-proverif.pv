(*  Regular
1. A->S: A, B, Na
2. S->A: {Na, Kab, B, {Kab, A}Kbs}Kas
  * A checks that recipient's name natches (B=B)
  * A checks that nonce Na matches
3. A->B: {Kab, a}Kbs
4. B->A: {Nb}Kab
5. A->B: {Nb+1}Kab
  * B checks that nonce Nb matches
*)

(* Fixed
1. A->B: A
2. B->A: {A, J}Kbs
3. A->AS: A, B, Na, {A, J}Kbs
  * AS checks that sender matches the ini in identifier
4. AS->A: {Na, Kab, B, {Kab, A, J}Kbs}Kas
  * A checks that recipient's name natches (B=B)
  * A checks that nonce Na matches
5. A->B: {Kab, A, J}Kbs
  * B checks that nonce J matches original
6. B->A: {Nb}Kab
7. A->B: {Nb+1}Kab
  * B checks that nonce Nb matches
*)

free c: channel.

type host.
type key.
free k_res_S: key [private].
free k_ini_S: key [private].
free k_ini_res:key[private].
free A, B: host.



event ini_accept_key(key, host, host).
event res_accept_key(key).
event ini_completes_protocol(key, host, host).
event res_completes_protocol(key, host).
    
    
event res_runs_protocol(host,bitstring).
event ini_runs_protocol(host,bitstring).


query k: key, i: host, r: host; event(ini_accept_key(k,i,r)) && attacker(k)==>false.
query k: key; event(res_accept_key(k)) && attacker(k)==>false.

query k: key; inj-event(res_completes_protocol(k,A))==>inj-event(ini_completes_protocol(k,A,B)).
    
query x: bitstring; inj-event(ini_runs_protocol(A,x))==>inj-event(res_runs_protocol(B,x)).

fun encrypt(bitstring, key): bitstring.
reduc forall m: bitstring, k: key; decrypt(encrypt(m,k),k) = m.

fun modify(bitstring): bitstring.
reduc forall x:bitstring; unmodify(modify(x))=x.

(* ini *)
let initiator(k_ini_S:key, ini: host, res: host) =
(* 1 *)
  out(c, (ini));

(* 3 *)
  in(c, mJ: bitstring);
  new n_ini: bitstring;
  let m2= (ini, res, n_ini, mJ) in
  out(c, m2);

(* 5 *)
  in(c, x: bitstring);
  let (=n_ini, received_k_ini_res: key,=res, received_msg_for_responder: bitstring) = decrypt(x, k_ini_S) in
  event ini_accept_key(received_k_ini_res,ini,res);
 
  out(c, received_msg_for_responder);

(* 7 *)
  in(c, z: bitstring);
  let received_n_res = decrypt(z, received_k_ini_res) in
  event ini_runs_protocol(res, (received_msg_for_responder,z));
  event ini_completes_protocol(received_k_ini_res, ini, res);
  out(c, encrypt(modify(received_n_res), received_k_ini_res)).

let server(k_ini_S:key, k_res_S: key, k_ini_res: key, ini: host, res: host) =
(* 4 *)
  in(c, (Sini: host, Sres: host, n_ini: bitstring, A_mJ: bitstring));
  if Sini=ini && Sres=res then
  let (received_B_ini: host, received_B_n_J: bitstring) = decrypt(A_mJ, k_res_S) in
  if Sini = received_B_ini then

  let msg_for_responder = encrypt((k_ini_res, ini, received_B_n_J), k_res_S) in
  out(c, encrypt((n_ini, k_ini_res, res, msg_for_responder), k_ini_S)).

(* res *)
let responder(k_res_S:key, res: host) =
(* 2 *)
  in(c, received_ini: host);
  new n_J: bitstring;
  out(c, encrypt((received_ini, n_J), k_res_S));

(* 6 *)
  in(c, y: bitstring);
  let (received_k_ini_res: key, received_AS_ini: host, received_n_J: bitstring) = decrypt(y, k_res_S) in
  if received_n_J = n_J then 
  new n_res: bitstring; 
  let E=encrypt(n_res, received_k_ini_res) in
  event res_runs_protocol(received_ini,(y,E));
  out(c, E);

(* 7 *)
  in(c, m: bitstring);
  let n_res_modified = decrypt(m, received_k_ini_res) in
  let nB_modified_unmodified = unmodify(n_res_modified) in
  if nB_modified_unmodified = n_res then
  event res_accept_key(received_k_ini_res);
  event res_completes_protocol(received_k_ini_res,received_ini).

process
  
  new k_ini_S:key;
  new k_res_S:key;
  
  (
  (!initiator(k_ini_S, A, B)) | (!server(k_ini_S, k_res_S, k_ini_res, A, B)) | (!responder(k_res_S, B))  
  )