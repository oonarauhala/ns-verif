(*
1. A->S: A, B, Na
2. S->A: {Na, Kab, B, {Kab, A}Kbs}Kas
  * A checks that recipient's name natches (B=B)
  * A checks that nonce Na matches
3. A->B: {Kab, a}Kbs
4. B->A: {Nb}Kab
5. A->B: {Nb+1}Kab
  * B checks that nonce Nb matches
*)

free c: channel.

type host.
type key.
free k_res_S: key [private].
free k_ini_S: key [private].

event ini_accept_key(key).
event res_accept_key(key).
event ini_completes_protocol(key).
event res_completes_protocol(key).
event res_runs_protocol(bitstring, key).
event ini_runs_protocol(bitstring).

query k: key, x: bitstring; event(ini_completes_protocol(k))==>event(res_runs_protocol(x, k)).
query k: key; event(ini_accept_key(k)) && attacker(k)==>false.
query k: key; event(res_accept_key(k)) && attacker(k)==>false.
query k: key, x: bitstring; inj-event(ini_completes_protocol(k))==>event(res_runs_protocol(x, k)).
query k: key, x: bitstring; inj-event(res_completes_protocol(k))==>event(ini_runs_protocol(x)).

fun encrypt(bitstring, key): bitstring.
reduc forall m: bitstring, k: key; decrypt(encrypt(m,k),k) = m.

fun modify(bitstring): bitstring.
reduc forall x:bitstring; unmodify(modify(x))=x.

(* ini *)
let initiator(k_ini_S:key, ini: host, res: host) =
  out(c, (ini));
  in(c, mJ: bitstring);

  new n_ini: bitstring;
  out(c, (ini, res, n_ini, mJ));
  in(c, x: bitstring);
  let (received_n_ini: bitstring, received_k_ini_res: key, received_res: host, received_msg_for_responder: bitstring) = decrypt(x, k_ini_S) in
  if received_res = res then
  if received_n_ini = n_ini then
  event ini_accept_key(received_k_ini_res);
  event ini_runs_protocol(n_ini);
  out(c, received_msg_for_responder);
  in(c, z: bitstring);
  let received_n_res = decrypt(z, received_k_ini_res) in
  event ini_completes_protocol(received_k_ini_res);
  out(c, encrypt(modify(received_n_res), received_k_ini_res)).

let server(k_ini_S:key, k_res_S: key, k_ini_res: key, ini: host, res: host) =
  in(c, (received_A_ini: host, received_A_res: host, received_n_ini: bitstring, received_A_mJ: bitstring));
  let (received_B_ini: host, received_B_n_J: bitstring) = decrypt(received_A_mJ, k_res_S) in
  if received_A_ini = received_B_ini then

  let msg_for_responder = encrypt((k_ini_res, ini, received_B_n_J), k_res_S) in
  out(c, encrypt((received_n_ini, k_ini_res, res, msg_for_responder), k_ini_S)).

(* res *)
let responder(k_res_S:key, ini: host, res: host) =
  in(c, received_ini: host);
  new n_J: bitstring;
  out(c, encrypt((received_ini, n_J), k_res_S));

  in(c, y: bitstring);
  let (received_k_ini_res: key, received_AS_ini: host, received_n_J: bitstring) = decrypt(y, k_res_S) in
  if received_n_J = n_J then 

  new n_res: bitstring; 
  event res_runs_protocol(n_res, received_k_ini_res);
  out(c, encrypt(n_res, received_k_ini_res));
  in(c, m: bitstring);
  let n_res_modified = decrypt(m, received_k_ini_res) in
  let nB_modified_unmodified = unmodify(n_res_modified) in
  if nB_modified_unmodified = n_res then
  event res_accept_key(received_k_ini_res);
  event res_completes_protocol(received_k_ini_res).

process
  new k_ini_res: key;
  new A: host;
  new B: host;
  
  (
  (!initiator(k_ini_S, A, B)) | (!server(k_ini_S, k_res_S, k_ini_res, A, B)) | (!responder(k_res_S, A, B))
  | (!initiator(k_ini_S, B, A)) | (!server(k_ini_S, k_res_S, k_ini_res, B, A)) | (!responder(k_res_S, B, A)) 
  | phase 1; out(c, k_ini_res)
  )
