(*
1. A->S: A, B, Na
2. S->A: {Na, Kab, B, {Kab, A}Kbs}Kas
  * A checks that recipient's name natches (B=B)
  * A checks that nonce Na matches
3. A->B: {Kab, a}Kbs
4. B->A: {Nb}Kab
5. A->B: {Nb+1}Kab
  * B checks that nonce Nb matches
*)

free c: channel.

type host.
type key.
free k_res_S: key [private].
free k_ini_S: key [private].

free A, B: host.

event ini_accept_key(key).
event ini_completes_protocol(key).
event res_completes_protocol(key).
event res_runs_protocol(bitstring, key).
event ini_runs_protocol(bitstring).
event res_accept_key(key).

query k: key, x: bitstring; event(ini_completes_protocol(k))==>event(res_runs_protocol(x, k)).
query k: key; event(ini_accept_key(k)) && attacker(k)==>false.
query k: key; event(res_accept_key(k)) && attacker(k)==>false.
query k: key, x: bitstring; inj-event(ini_completes_protocol(k))==>event(res_runs_protocol(x, k)).
query k: key, x: bitstring; inj-event(res_completes_protocol(k))==>event(ini_runs_protocol(x)).

fun encrypt(bitstring, key): bitstring.
reduc forall m: bitstring, k: key; decrypt(encrypt(m,k),k) = m.

fun addition(bitstring, nat): bitstring.
reduc forall x:bitstring, y:nat; subtraction(addition(x,y),y)=x.

(* ini *)
let initiator(k_ini_S:key, ini: host, res: host) =
  new n_ini: bitstring;
  out(c, (ini, res, n_ini));
  in(c, x: bitstring);
  let (received_n_ini: bitstring, received_k_ini_res: key, received_res: host, received_msg_for_responder: bitstring) = decrypt(x, k_ini_S) in
  if received_res = res then
  if received_n_ini = n_ini then
  event ini_accept_key(received_k_ini_res);
  event ini_runs_protocol(n_ini);
  out(c, received_msg_for_responder);
  in(c, z: bitstring);
  let received_n_res = decrypt(z, received_k_ini_res) in
  event ini_completes_protocol(received_k_ini_res);
  out(c, encrypt(addition(received_n_res, 1), received_k_ini_res)).

let server(k_ini_S:key, k_res_S: key, k_ini_res: key, ini: host, res: host) =
  in(c, (ini: host, res: host, n_ini: bitstring));
  let msg_for_responder = encrypt((k_ini_res, ini), k_res_S) in
  out(c, encrypt((n_ini, k_ini_res, res, msg_for_responder), k_ini_S)).

(* res *)
let responder(k_res_S:key, ini: host, res: host) =
  in(c, y: bitstring);
  let (received_k_ini_res: key, received_ini: host) = decrypt(y, k_res_S) in
  new n_res: bitstring; 
  event res_runs_protocol(n_res, received_k_ini_res);
  out(c, encrypt(n_res, received_k_ini_res));
  in(c, m: bitstring);
  let n_res_modified = decrypt(m, received_k_ini_res) in
  let nB_modified_unmodified = subtraction(n_res_modified, 1) in
  if nB_modified_unmodified = n_res then
  event res_accept_key(received_k_ini_res);
  event res_completes_protocol(received_k_ini_res).

process
  new k_ini_res: key;
  new A: host;
  new B: host;
  
  (
  (!initiator(k_ini_S, A, B)) | (!server(k_ini_S, k_res_S, k_ini_res, A, B)) | (!responder(k_res_S, A, B)
  | (!initiator(k_ini_S, B, A) | (!server(k_ini_S, k_res_S, k_ini_res, B, A)) | (!responder(k_res_S, B, A))) 
  ) | phase 1; out(c, k_ini_res) )
