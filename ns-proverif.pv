(*
1. A->S: A, B, Na
2. S->A: {Na, Kab, B, {Kab, A}Kbs}Kas
  * A checks that recipient's name natches (B=B)
  * A checks that nonce Na matches
3. A->B: {Kab, a}Kbs
4. B->A: {Nb}Kab
5. A->B: {Nb+1}Kab
  * B checks that nonce Nb matches
*)

free c: channel.

type host.
type key.
free Sa: bitstring [private].
free Sb: bitstring [private].
query attacker(Sa).
query attacker(Sb).
free kBS: key [private].
free kAS: key [private].

free A, B: host.

fun encrypt(bitstring, key): bitstring.
reduc forall m: bitstring, k: key; decrypt(encrypt(m,k),k) = m.

fun addition(bitstring, nat): bitstring.
reduc forall x:bitstring, y:nat; substraction(addition(x,y),y)=x.

let clientA(kAS:key) =
  new nA: bitstring; 
  out(c, (A, B, nA));
  in(c, x: bitstring);
  let (received_nA: bitstring, received_kAB: key, received_hostB: host, received_Ma: bitstring) = decrypt(x, kAS) in
  if received_hostB = B then
  if received_nA = nA then
  out(c, received_Ma);
  in(c, z: bitstring);
  let received_B_nB = decrypt(z, received_kAB) in
  out(c, encrypt(addition(received_B_nB, 1), received_kAB));
  out(c, encrypt(Sa, received_kAB)).

let serverS(kAS:key, kBS: key) =
  in(c, (hostA: host, hostB: host, SnA: bitstring));
  new kAB: key;
  let Ma = encrypt((kAB, A), kBS) in
  out(c, encrypt((SnA, kAB, B, Ma), kAS)).

let clientB(kBS:key) = 
  in(c, y: bitstring);
  let (received_A_kAB: key, received_hostA: host) = decrypt(y, kBS) in
  new nB: bitstring;  
  out(c, encrypt(nB, received_A_kAB));
  in(c, m: bitstring);
  let nB_modified = decrypt(m, received_A_kAB) in
  let nB_modified_unmodified = substraction(nB_modified, 1) in
  if nB_modified_unmodified = nB then
  out(c, encrypt(Sb, received_A_kAB)).

process
  
  ( (!clientA(kAS)) | (!serverS(kAS, kBS)) | (!clientB(kBS)) )
